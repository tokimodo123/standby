<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Standby</title>
  <style>
    :root{
      --bg:#070b10;
      --fg:#e6edf3;
      --muted: rgba(230,237,243,.68);
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.10);
      --border: rgba(255,255,255,.12);
      --shadow: rgba(0,0,0,.25);
    }
    [data-theme="light"]{
      --bg:#f6f7fb;
      --fg:#0b1220;
      --muted: rgba(11,18,32,.60);
      --panel: rgba(0,0,0,.05);
      --panel2: rgba(0,0,0,.08);
      --border: rgba(0,0,0,.12);
      --shadow: rgba(0,0,0,.08);
    }

    html,body{height:100%; margin:0; background:var(--bg); color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Display", "Hiragino Sans", "Noto Sans JP", sans-serif;}
    body{overflow:hidden;}

    .wrap{
      position:fixed; inset:0;
      padding: 18px 18px calc(18px + env(safe-area-inset-bottom));
      display:grid;
      grid-template-columns: 1fr 1fr; /* Â∑¶=ÊôÇË®à, Âè≥=„Ç¢„Éã„É° */
      gap:14px;
    }

    .left, .right{
      border-radius: 24px;
      background: var(--panel);
      border:1px solid rgba(255,255,255,.08);
      border-color: var(--border);
      overflow:hidden;
      position:relative;
    }

    .leftInner{
      padding:18px;
      display:grid;
      grid-template-rows: auto auto 1fr;
      gap:14px;
      height:100%;
      box-sizing:border-box;
    }

    .topRow{
      display:flex; align-items:flex-start; justify-content:space-between; gap:12px;
    }

    .digital{
      font-variant-numeric: tabular-nums;
      letter-spacing: .02em;
      line-height:1;
    }
    .digital .time{
      font-size: 108px;
      font-weight: 900;
    }
    .digital .date{
      margin-top:10px;
      font-size: 18px;
      color: var(--muted);
    }

    .controls{
      display:flex; gap:10px; align-items:flex-start; flex-wrap:wrap; justify-content:flex-end;
    }
    .btn{
      appearance:none;
      border:1px solid var(--border);
      background: var(--panel2);
      color: var(--fg);
      padding: 12px 14px;
      border-radius: 16px;
      font-size: 14px;
      font-weight: 750;
      cursor:pointer;
      white-space:nowrap;
      box-shadow: 0 8px 18px var(--shadow);
    }
    .btn:active{transform: translateY(1px);}

    .midRow{
      display:grid;
      grid-template-columns: 1fr 1fr; /* Â∑¶„Ç¢„Éä„É≠„Ç∞, Âè≥Â§©Ê∞ó */
      gap:14px;
      align-items:stretch;
    }

    .card{
      border-radius: 20px;
      background: var(--panel);
      border:1px solid var(--border);
      padding:14px;
      box-sizing:border-box;
      min-height: 160px;
    }
    .label{font-size:12px; color:var(--muted); margin-bottom:10px;}
    .wxMain{display:flex; align-items:center; gap:12px;}
    .wxIcon{font-size:32px; width:38px; text-align:center;}
    .wxTemp{font-size:28px; font-weight:900; line-height:1;}
    .wxPlace{margin-top:6px; font-size:14px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .wxDetail{margin-top:6px; font-size:12px; color:var(--muted);}
    .wxMeta{margin-top:10px; font-size:12px; color:var(--muted);}

    .analogWrap{
      display:flex; align-items:center; justify-content:center;
      height:100%;
    }

    /* „Ç¢„Éä„É≠„Ç∞ÊôÇË®àÔºàSVGÔºâ */
    .clockSvg{
      width: min(260px, 22vw);
      height: auto;
      filter: drop-shadow(0 10px 22px var(--shadow));
    }
    .dial{fill: color-mix(in srgb, var(--bg) 70%, transparent); stroke: var(--border); stroke-width: 2;}
    .tick{stroke: color-mix(in srgb, var(--fg) 60%, transparent); stroke-width: 2; opacity:.55}
    .tickBig{stroke: color-mix(in srgb, var(--fg) 80%, transparent); stroke-width: 3; opacity:.75}
    .handH{stroke: var(--fg); stroke-width: 8; stroke-linecap: round;}
    .handM{stroke: var(--fg); stroke-width: 6; stroke-linecap: round; opacity:.95}
    .handS{stroke: color-mix(in srgb, #ff4d6d 70%, var(--fg)); stroke-width: 3; stroke-linecap: round; opacity:.9}
    .pin{fill: var(--fg); opacity:.9}

    .right canvas{position:absolute; inset:0; width:100%; height:100%;}
    .rightBottom{
      position:absolute;
      right: 14px;
      bottom: 14px;
      display:flex;
      gap:10px;
      z-index: 5;
    }

    @media (max-width: 980px){
      .digital .time{font-size: 84px;}
      .midRow{grid-template-columns: 1fr;}
      .clockSvg{width:min(260px, 38vw);}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- LEFT -->
    <section class="left">
      <div class="leftInner">
        <div class="topRow">
          <div class="digital">
            <div class="time" id="time">--:--</div>
            <div class="date" id="date">----</div>
          </div>
          <div class="controls">
            <button class="btn" id="themeBtn">„Éõ„ÉØ„Ç§„Éà</button>
            <button class="btn" id="chatBtn">ChatGPT</button>
          </div>
        </div>

        <div class="midRow">
          <div class="card">
            <div class="label">ANALOG</div>
            <div class="analogWrap">
              <svg class="clockSvg" viewBox="0 0 200 200" aria-label="analog clock">
                <circle cx="100" cy="100" r="92" class="dial"></circle>
                <!-- ticks -->
                <g id="ticks"></g>

                <!-- hands -->
                <g transform="translate(100 100)">
                  <line id="handH" x1="0" y1="10" x2="0" y2="-42" class="handH"></line>
                  <line id="handM" x1="0" y1="14" x2="0" y2="-62" class="handM"></line>
                  <line id="handS" x1="0" y1="18" x2="0" y2="-70" class="handS"></line>
                  <circle r="6" class="pin"></circle>
                </g>
              </svg>
            </div>
          </div>

          <div class="card" id="weatherCard">
            <div class="label">WEATHER</div>
            <div class="wxMain">
              <div class="wxIcon" id="wxIcon">‚õÖÔ∏è</div>
              <div>
                <div class="wxTemp" id="wxTemp">--¬∞C</div>
                <div class="wxPlace" id="wxPlace">ÂèñÂæó‰∏≠‚Ä¶</div>
                <div class="wxDetail" id="wxDetail">‚Äî</div>
              </div>
            </div>
            <div class="wxMeta" id="wxMeta">‚Äî</div>
          </div>
        </div>

        <div style="flex:1"></div>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="right">
      <canvas id="scene"></canvas>
      <div class="rightBottom">
        <button class="btn" id="retryWx">Â§©Ê∞óÊõ¥Êñ∞</button>
      </div>
    </section>
  </div>

<script>
(() => {
  // ---------- THEME ----------
  const themeKey = "standby_theme_v2";
  const root = document.documentElement;
  function setTheme(t){
    root.setAttribute("data-theme", t);
    localStorage.setItem(themeKey, t);
    document.getElementById("themeBtn").textContent = (t === "light") ? "„ÉÄ„Éº„ÇØ" : "„Éõ„ÉØ„Ç§„Éà";
  }
  const savedTheme = localStorage.getItem(themeKey);
  if(savedTheme) setTheme(savedTheme);
  else {
    const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
    setTheme(prefersLight ? "light" : "dark");
  }
  document.getElementById("themeBtn").addEventListener("click", ()=>{
    const cur = root.getAttribute("data-theme") || "dark";
    setTheme(cur === "dark" ? "light" : "dark");
  });

  // ---------- CHAT ----------
  document.getElementById("chatBtn").addEventListener("click", ()=>{
    window.open("https://chatgpt.com", "_blank");
  });

  // ---------- DIGITAL CLOCK ----------
  const timeEl = document.getElementById("time");
  const dateEl = document.getElementById("date");
  const pad = (n)=>String(n).padStart(2,"0");
  const dow = ["Êó•","Êúà","ÁÅ´","Ê∞¥","Êú®","Èáë","Âúü"];
  function tick(){
    const d = new Date();
    timeEl.textContent = `${pad(d.getHours())}:${pad(d.getMinutes())}`;
    dateEl.textContent = `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())} (${dow[d.getDay()]})`;
    updateAnalog(d);
    updateSceneTime(d);
  }
  setInterval(tick, 1000);
  tick();

  // ---------- ANALOG CLOCK ----------
  const ticksG = document.getElementById("ticks");
  // generate ticks once
  (() => {
    let s = "";
    for(let i=0;i<60;i++){
      const a = (Math.PI*2) * (i/60);
      const r1 = 80;
      const r2 = (i%5===0) ? 70 : 74;
      const x1 = 100 + Math.sin(a)*r1;
      const y1 = 100 - Math.cos(a)*r1;
      const x2 = 100 + Math.sin(a)*r2;
      const y2 = 100 - Math.cos(a)*r2;
      const cls = (i%5===0) ? "tickBig" : "tick";
      s += `<line x1="${x1.toFixed(2)}" y1="${y1.toFixed(2)}" x2="${x2.toFixed(2)}" y2="${y2.toFixed(2)}" class="${cls}" />`;
    }
    ticksG.innerHTML = s;
  })();

  const handH = document.getElementById("handH");
  const handM = document.getElementById("handM");
  const handS = document.getElementById("handS");

  function rot(el, deg){
    el.setAttribute("transform", `rotate(${deg})`);
  }
  function updateAnalog(d){
    const h = d.getHours()%12;
    const m = d.getMinutes();
    const s = d.getSeconds();
    const ms = d.getMilliseconds();

    const sec = s + ms/1000;
    const min = m + sec/60;
    const hour = h + min/60;

    rot(handS, sec*6);
    rot(handM, min*6);
    rot(handH, hour*30);
  }

  // ---------- WEATHER (stronger / fallback) ----------
  const wxIconEl = document.getElementById("wxIcon");
  const wxTempEl = document.getElementById("wxTemp");
  const wxPlaceEl = document.getElementById("wxPlace");
  const wxDetailEl = document.getElementById("wxDetail");
  const wxMetaEl = document.getElementById("wxMeta");

  let currentWxCode = null; // for scene effects
  let currentWxWind = null;

  function weatherEmoji(code){
    if(code === 0) return "‚òÄÔ∏è";
    if([1,2].includes(code)) return "üå§Ô∏è";
    if(code === 3) return "‚òÅÔ∏è";
    if([45,48].includes(code)) return "üå´Ô∏è";
    if([51,53,55,56,57].includes(code)) return "üå¶Ô∏è";
    if([61,63,65,66,67].includes(code)) return "üåßÔ∏è";
    if([71,73,75,77].includes(code)) return "üå®Ô∏è";
    if([80,81,82].includes(code)) return "üåßÔ∏è";
    if([85,86].includes(code)) return "üå®Ô∏è";
    if([95,96,99].includes(code)) return "‚õàÔ∏è";
    return "‚õÖÔ∏è";
  }
  function codeText(code){
    const m = new Map([
      [0,"Âø´Êô¥"],[1,"Êô¥„Çå"],[2,"Êô¥„ÇåÊôÇ„ÄÖÊõá„Çä"],[3,"Êõá„Çä"],
      [45,"Èúß"],[48,"Èúß"],
      [51,"ÈúßÈõ®(Âº±)"],[53,"ÈúßÈõ®(‰∏≠)"],[55,"ÈúßÈõ®(Âº∑)"],
      [56,"ÂáçÁµêÈúßÈõ®(Âº±)"],[57,"ÂáçÁµêÈúßÈõ®(Âº∑)"],
      [61,"Èõ®(Âº±)"],[63,"Èõ®(‰∏≠)"],[65,"Èõ®(Âº∑)"],
      [66,"ÂáçÁµêÈõ®(Âº±)"],[67,"ÂáçÁµêÈõ®(Âº∑)"],
      [71,"Èõ™(Âº±)"],[73,"Èõ™(‰∏≠)"],[75,"Èõ™(Âº∑)"],[77,"Èú∞(„ÅÇ„Çâ„Çå)"],
      [80,"„Å´„Çè„ÅãÈõ®(Âº±)"],[81,"„Å´„Çè„ÅãÈõ®(‰∏≠)"],[82,"„Å´„Çè„ÅãÈõ®(Âº∑)"],
      [85,"„Å´„Çè„ÅãÈõ™(Âº±)"],[86,"„Å´„Çè„ÅãÈõ™(Âº∑)"],
      [95,"Èõ∑Èõ®"],[96,"Èõ∑Èõ®(Èõπ)"],[99,"Èõ∑Èõ®(Èõπ)"]
    ]);
    return m.get(code) ?? `Â§©Ê∞ó„Ç≥„Éº„Éâ ${code}`;
  }

  async function fetchWeather(lat, lon){
    const url =
      `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}` +
      `&current=temperature_2m,weather_code,wind_speed_10m` +
      `&timezone=Asia%2FTokyo`;
    const r = await fetch(url, { cache:"no-store" });
    if(!r.ok) throw new Error("weather fetch failed");
    return r.json();
  }
  async function reverseGeocode(lat, lon){
    const url =
      `https://geocoding-api.open-meteo.com/v1/reverse?latitude=${lat}&longitude=${lon}&language=ja`;
    const r = await fetch(url, { cache:"no-store" });
    if(!r.ok) return null;
    const j = await r.json();
    const p = j?.results?.[0];
    if(!p) return null;
    const parts = [p.name, p.admin1, p.country].filter(Boolean);
    // ‰æã: "Êñ∞ÂÆøÂå∫, Êù±‰∫¨ÈÉΩ, Êó•Êú¨"
    return parts.join(", ");
  }

  function setWxState({tempText="--¬∞C", place="ÂèñÂæó‰∏≠‚Ä¶", detail="‚Äî", meta="‚Äî", icon="‚õÖÔ∏è", code=null, wind=null}){
    wxTempEl.textContent = tempText;
    wxPlaceEl.textContent = place;
    wxDetailEl.textContent = detail;
    wxMetaEl.textContent = meta;
    wxIconEl.textContent = icon;
    currentWxCode = code;
    currentWxWind = wind;
  }

  async function updateWeatherWithCoords(lat, lon, placeHint=null){
    const [wx, place] = await Promise.all([
      fetchWeather(lat, lon),
      placeHint ? Promise.resolve(placeHint) : reverseGeocode(lat, lon)
    ]);

    const cur = wx.current;
    const temp = Math.round(cur.temperature_2m);
    const code = cur.weather_code;
    const wind = Math.round(cur.wind_speed_10m);

    setWxState({
      tempText: `${temp}¬∞C`,
      place: place ?? `lat ${lat.toFixed(2)}, lon ${lon.toFixed(2)}`,
      detail: `${codeText(code)} / È¢® ${wind}m/s`,
      meta: `ÊúÄÁµÇÊõ¥Êñ∞: ${new Date().toLocaleTimeString("ja-JP",{hour:"2-digit", minute:"2-digit"})}`,
      icon: weatherEmoji(code),
      code, wind
    });
  }

  async function updateWeather(){
    setWxState({ place:"‰ΩçÁΩÆÊÉÖÂ†±„ÇíÁ¢∫Ë™ç‰∏≠‚Ä¶", meta:"‚Äî" });

    // iPad Safari„Åß‰ΩçÁΩÆÊÉÖÂ†±„ÅåÂèñ„Çå„Å™„ÅÑÊôÇ„Åå„ÅÇ„Çã„ÅÆ„Åß„ÄÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÇíÁ¢∫ÂÆü„Å´„Åô„Çã
    const fallback = async (reason)=>{
      // Êù±‰∫¨ÈßÖ„ÅÇ„Åü„ÇäÔºàÂÆâÂÆöÔºâ
      await updateWeatherWithCoords(35.681236, 139.767125, `Êù±‰∫¨Ôºà‰ΩçÁΩÆÊÉÖÂ†±OFF: ${reason}Ôºâ`);
    };

    if(!navigator.geolocation){
      await fallback("ÈùûÂØæÂøú");
      return;
    }

    // Permissions API „ÅØSafari„Åß‰Ωø„Åà„Åü„Çä‰Ωø„Åà„Å™„Åã„Å£„Åü„Çä„Åô„Çã„ÅÆ„Åß try
    try{
      if(navigator.permissions?.query){
        const p = await navigator.permissions.query({ name: "geolocation" });
        if(p.state === "denied"){
          await fallback("ÊãíÂê¶");
          return;
        }
      }
    }catch(_){}

    navigator.geolocation.getCurrentPosition(async (pos)=>{
      try{
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        await updateWeatherWithCoords(lat, lon);
      }catch(e){
        await fallback("ÂèñÂæóÂ§±Êïó");
      }
    }, async (err)=>{
      await fallback(err?.code === 1 ? "ÊãíÂê¶" : "„Ç®„É©„Éº");
    }, { enableHighAccuracy:false, timeout: 9000, maximumAge: 10*60*1000 });
  }

  document.getElementById("retryWx").addEventListener("click", updateWeather);
  updateWeather();
  setInterval(updateWeather, 10*60*1000);

  // ---------- RIGHT SCENE (time-based sky + sun/moon + weather effects + walking human) ----------
  const canvas = document.getElementById("scene");
  const ctx = canvas.getContext("2d", { alpha: true });

  function resize(){
    const r = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width * r);
    canvas.height = Math.floor(rect.height * r);
    ctx.setTransform(r,0,0,r,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // time state shared
  let sceneHour = 12, sceneMin = 0, sceneSec = 0;

  function updateSceneTime(d){
    sceneHour = d.getHours();
    sceneMin = d.getMinutes();
    sceneSec = d.getSeconds();
  }

  // weather classification for effects
  function wxKind(code){
    if(code == null) return "unknown";
    if(code === 0 || code === 1) return "clear";
    if(code === 2 || code === 3) return "cloudy";
    if([45,48].includes(code)) return "fog";
    if([51,53,55,56,57].includes(code)) return "drizzle";
    if([61,63,65,66,67,80,81,82,95,96,99].includes(code)) return "rain";
    if([71,73,75,77,85,86].includes(code)) return "snow";
    return "cloudy";
  }

  // draw helpers
  function lerp(a,b,t){ return a + (b-a)*t; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  // simple star field
  const stars = Array.from({length: 110}, (_,i)=>({
    x: (i*97)%1000 / 1000,
    y: (i*173)%1000 / 1000,
    s: ((i*37)%7)+1
  }));

  // clouds particles
  const clouds = Array.from({length: 9}, (_,i)=>({
    x: Math.random()*1.2 - 0.1,
    y: Math.random()*0.35 + 0.08,
    v: 0.010 + Math.random()*0.02,
    w: 0.18 + Math.random()*0.18
  }));

  // rain/snow particles
  const drops = Array.from({length: 180}, ()=>({
    x: Math.random(),
    y: Math.random(),
    v: 0.8 + Math.random()*1.2,
    l: 0.015 + Math.random()*0.02
  }));
  const flakes = Array.from({length: 140}, ()=>({
    x: Math.random(),
    y: Math.random(),
    v: 0.12 + Math.random()*0.25,
    s: 0.004 + Math.random()*0.008,
    w: (Math.random()*2-1) * 0.10
  }));

  // walking human pixel sprite (16x24) two frames
  function drawPixelHuman(x, y, scale, frame, facing=1){
    const s = scale;
    const px = (ix,iy,col)=>{
      ctx.fillStyle = col;
      ctx.fillRect(x + ix*s, y + iy*s, s, s);
    };

    // palette based on theme
    const isLight = (root.getAttribute("data-theme") === "light");
    const skin = isLight ? "#F2C9A0" : "#E7B98D";
    const hair = isLight ? "#2b2b2b" : "#1b1b1b";
    const shirt= isLight ? "#4f8cff" : "#6aa7ff";
    const pants= isLight ? "#2e3a4f" : "#1f2a3b";
    const shoe = isLight ? "#111" : "#0a0a0a";

    // two leg frames
    const step = (Math.floor(frame)%2);

    // 16x24 coordinate system
    // head
    const head = [
      "....######......",
      "...########.....",
      "...########.....",
      "...########.....",
      "....######......",
    ];
    // body (shirt)
    const body = [
      "....####........",
      "...######.......",
      "...######.......",
      "...######.......",
      "...######.......",
      "....####........",
    ];
    // legs
    const legA = [
      "..##....##......",
      "..##....##......",
      "..##....##......",
      "..##....##......",
      "..##....##......",
      "..##....##......",
    ];
    const legB = [
      "..##....##......",
      "..##....##......",
      "..##....##......",
      "..##....##......",
      "..##....##......",
      "...##..##.......",
    ];

    // draw head
    for(let iy=0; iy<head.length; iy++){
      for(let ix=0; ix<16; ix++){
        if(head[iy][ix]==="#"){
          // hair top rows
          const col = (iy<=1) ? hair : skin;
          px(ix,iy,col);
        }
      }
    }
    // eyes
    px(6,2, "#0b0b0b"); px(9,2, "#0b0b0b");

    // draw body
    const by0 = 6;
    for(let iy=0; iy<body.length; iy++){
      for(let ix=0; ix<16; ix++){
        if(body[iy][ix]==="#") px(ix, by0+iy, shirt);
      }
    }

    // arms (simple)
    px(4,8, skin); px(11,8, skin);
    px(3,9, skin); px(12,9, skin);

    // waist
    px(6,12, pants); px(7,12, pants); px(8,12, pants); px(9,12, pants);

    // legs
    const ly0 = 13;
    const legs = (step===0) ? legA : legB;
    for(let iy=0; iy<legs.length; iy++){
      for(let ix=0; ix<16; ix++){
        if(legs[iy][ix]==="#") px(ix, ly0+iy, pants);
      }
    }
    // shoes
    px(5, ly0+5, shoe); px(10, ly0+5, shoe);

    // backpack-ish (optional small)
    px(2,9, isLight ? "#ffb703" : "#ffd166");
    px(2,10, isLight ? "#ffb703" : "#ffd166");
  }

  // scene state
  const dude = { x: 0.25, y: 0.70, v: 0.06, dir: 1 };
  let t = 0;

  function skyParams(hourFloat){
    // hourFloat: 0..24
    // segments: night(0-5), morning(5-9), day(9-16), sunset(16-19), night(19-24)
    const h = hourFloat;

    function mix(c1,c2,k){
      // c as [r,g,b]
      return [lerp(c1[0],c2[0],k), lerp(c1[1],c2[1],k), lerp(c1[2],c2[2],k)];
    }
    const nightTop=[12,16,28], nightBot=[8,10,18];
    const mornTop=[120,175,255], mornBot=[240,210,160];
    const dayTop =[80,170,255], dayBot =[200,240,255];
    const setTop =[255,140,120], setBot=[80,50,120];

    let top, bot, nightness;
    if(h<5){
      top=nightTop; bot=nightBot; nightness=1;
    }else if(h<9){
      const k=(h-5)/4;
      top=mix(nightTop,mornTop,k);
      bot=mix(nightBot,mornBot,k);
      nightness=1-k;
    }else if(h<16){
      const k=(h-9)/7;
      top=mix(mornTop,dayTop,k);
      bot=mix(mornBot,dayBot,k);
      nightness=0;
    }else if(h<19){
      const k=(h-16)/3;
      top=mix(dayTop,setTop,k);
      bot=mix(dayBot,setBot,k);
      nightness=k*0.6;
    }else{
      const k=(h-19)/5;
      top=mix(setTop,nightTop,clamp(k,0,1));
      bot=mix(setBot,nightBot,clamp(k,0,1));
      nightness=0.6+0.4*clamp(k,0,1);
    }
    return {top, bot, nightness};
  }

  function drawScene(dt){
    t += dt;
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    const hourFloat = sceneHour + sceneMin/60 + sceneSec/3600;
    const {top, bot, nightness} = skyParams(hourFloat);

    // background gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, `rgb(${top[0]|0},${top[1]|0},${top[2]|0})`);
    g.addColorStop(1, `rgb(${bot[0]|0},${bot[1]|0},${bot[2]|0})`);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // sun/moon path (simple arc across sky)
    // sun: 6-18, moon: 18-30 (wrap)
    const sunActive = (hourFloat >= 6 && hourFloat < 18);
    const progSun = clamp((hourFloat - 6)/12, 0, 1); // 0..1
    const progMoon = clamp(((hourFloat >= 18 ? hourFloat : hourFloat+24) - 18)/12, 0, 1);

    function bodyPos(p){
      // arc: left->right; higher at middle
      const x = lerp(0.08, 0.92, p);
      const y = 0.60 - Math.sin(p*Math.PI)*0.42;
      return {x,y};
    }

    // stars at night
    if(nightness > 0.15){
      ctx.globalAlpha = clamp((nightness-0.1)/0.9, 0, 1) * 0.65;
      ctx.fillStyle = "white";
      for(const s of stars){
        const tw = 0.35 + 0.65*(0.5+0.5*Math.sin(t*1.2 + s.s));
        const x = s.x*W, y = s.y*H*0.65;
        ctx.globalAlpha = clamp((nightness-0.1)/0.9, 0, 1) * 0.65 * tw;
        ctx.fillRect(x, y, 2, 2);
      }
      ctx.globalAlpha = 1;
    }

    // sun / moon
    const isLight = (root.getAttribute("data-theme")==="light");
    if(sunActive){
      const p = bodyPos(progSun);
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.fillStyle = isLight ? "rgba(255,210,120,.95)" : "rgba(255,214,140,.95)";
      ctx.arc(p.x*W, p.y*H, 22, 0, Math.PI*2);
      ctx.fill();
      // glow
      ctx.globalAlpha = 0.22;
      ctx.beginPath();
      ctx.arc(p.x*W, p.y*H, 55, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }else{
      const p = bodyPos(progMoon);
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.fillStyle = isLight ? "rgba(255,255,255,.90)" : "rgba(230,240,255,.90)";
      ctx.arc(p.x*W, p.y*H, 18, 0, Math.PI*2);
      ctx.fill();
      // crater-ish
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "rgba(0,0,0,.25)";
      ctx.beginPath(); ctx.arc(p.x*W+6, p.y*H-4, 4, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    // ground
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = isLight ? "rgba(0,0,0,.55)" : "rgba(0,0,0,.65)";
    ctx.fillRect(0, H*0.78, W, H*0.22);
    ctx.globalAlpha = 1;

    // weather overlay
    const kind = wxKind(currentWxCode);

    // clouds/fog
    if(kind==="cloudy" || kind==="drizzle" || kind==="rain" || kind==="fog" || kind==="snow"){
      const baseAlpha = (kind==="fog") ? 0.55 : 0.28;
      ctx.globalAlpha = baseAlpha;
      for(const c of clouds){
        c.x += c.v * dt * (1 + (currentWxWind? currentWxWind/20 : 0));
        if(c.x > 1.25) c.x = -0.25;
        const cx = c.x*W;
        const cy = c.y*H;
        const w = c.w*W;
        const h = w*0.35;
        ctx.fillStyle = isLight ? "rgba(255,255,255,.90)" : "rgba(255,255,255,.85)";
        // simple cloud as 3 circles
        ctx.beginPath();
        ctx.ellipse(cx, cy, w*0.28, h*0.55, 0, 0, Math.PI*2);
        ctx.ellipse(cx+w*0.18, cy-h*0.15, w*0.22, h*0.50, 0, 0, Math.PI*2);
        ctx.ellipse(cx-w*0.18, cy-h*0.10, w*0.24, h*0.52, 0, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // rain
    if(kind==="rain" || kind==="drizzle" || kind==="thunder"){
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = isLight ? "rgba(0,0,0,.22)" : "rgba(255,255,255,.20)";
      ctx.lineWidth = 2;
      for(const d of drops){
        d.y += d.v * dt * 0.8;
        d.x += 0.05 * dt; // slight wind
        if(d.y > 1){ d.y = -Math.random()*0.2; d.x = Math.random(); }
        if(d.x > 1.1) d.x = -0.1;
        const x = d.x*W;
        const y = d.y*H;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+8, y+H*d.l);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // snow
    if(kind==="snow"){
      ctx.globalAlpha = 0.65;
      ctx.fillStyle = isLight ? "rgba(255,255,255,.95)" : "rgba(255,255,255,.85)";
      for(const f of flakes){
        f.y += f.v * dt;
        f.x += (f.w * dt) + 0.02*Math.sin(t*0.6 + f.y*10)*dt;
        if(f.y > 1){ f.y = -Math.random()*0.2; f.x = Math.random(); }
        if(f.x > 1.1) f.x = -0.1;
        const x = f.x*W;
        const y = f.y*H;
        ctx.fillRect(x, y, 2, 2);
      }
      ctx.globalAlpha = 1;
    }

    // walking human
    dude.x += dude.v * dt * dude.dir;
    if(dude.x > 0.92){ dude.x = 0.92; dude.dir = -1; }
    if(dude.x < 0.08){ dude.x = 0.08; dude.dir = 1; }

    const scale = 5.5;
    const remember = ctx.getTransform();

    ctx.save();
    const pxX = dude.x*W;
    const pxY = dude.y*H;
    // little bob
    const bob = Math.sin(t*6.0)*3;
    // flip
    ctx.translate(pxX, pxY + bob);
    ctx.scale(dude.dir, 1);
    // shadow
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.ellipse(0, 62, 40, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    drawPixelHuman(-16*scale/2, -24*scale, scale, t*12, dude.dir);
    ctx.restore();

    ctx.setTransform(remember);
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    // clear & redraw
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width, rect.height);
    drawScene(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>

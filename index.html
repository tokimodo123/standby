<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Standby</title>
  <style>
    :root{
      --bg:#0a0f16;
      --fg:#e7eef7;
      --muted: rgba(231,238,247,.65);
      --panel: rgba(255,255,255,.07);
      --panel2: rgba(255,255,255,.10);
      --border: rgba(255,255,255,.12);
      --shadow: rgba(0,0,0,.28);
      --accent:#ff5473;

      --ui-scale: 1;
      --base-font: 16px;
    }
    html{ font-size: calc(var(--base-font) * var(--ui-scale)); }
    html[data-theme="light"]{
      --bg:#f6f7fb;
      --fg:#0b1220;
      --muted: rgba(11,18,32,.58);
      --panel: rgba(0,0,0,.05);
      --panel2: rgba(0,0,0,.08);
      --border: rgba(0,0,0,.12);
      --shadow: rgba(0,0,0,.08);
      --accent:#ff2f5a;
    }
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Display", "Hiragino Sans", "Noto Sans JP", sans-serif;
    }
    body{overflow:hidden;}

    .wrap{
      position:fixed; inset:0;
      padding: 1.125rem 1.125rem calc(1.125rem + env(safe-area-inset-bottom));
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: .875rem;
      box-sizing:border-box;
    }
    .panel{
      border-radius: 1.5rem;
      background: var(--panel);
      border: 1px solid var(--border);
      overflow:hidden;
      position:relative;
      min-height: 0;
    }
    html[data-orient="portrait"] .wrap{
      grid-template-columns: 1fr;
      grid-template-rows: 1fr 1fr;
    }

    /* LEFT */
    .leftInner{
      height:100%;
      padding:1.125rem;
      box-sizing:border-box;
      display:grid;
      grid-template-rows: auto auto auto 1fr;
      gap:.875rem;
      min-height:0;
    }
    .topRow{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:.75rem;
    }
    .digital{
      font-variant-numeric: tabular-nums;
      letter-spacing: .02em;
      line-height:1;
    }
    .digital .time{ font-size: 7rem; font-weight: 900; }
    .digital .date{
      margin-top:.625rem;
      font-size: 1.125rem;
      color: var(--muted);
    }
    .controls{
      display:flex;
      flex-direction:column;
      gap:.625rem;
      align-items:flex-end;
    }
    .btn{
      appearance:none;
      border: 1px solid var(--border);
      background: var(--panel2);
      color: var(--fg);
      padding: .75rem .875rem;
      border-radius: 1rem;
      font-size: .875rem;
      font-weight: 800;
      cursor:pointer;
      white-space:nowrap;
      box-shadow: 0 .625rem 1.375rem var(--shadow);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:active{transform: translateY(1px);}

    .midRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:.875rem;
      align-items:stretch;
      min-height:0;
    }
    html[data-orient="portrait"] .midRow{ grid-template-columns: 1fr; }

    .card{
      border-radius: 1.25rem;
      background: var(--panel);
      border: 1px solid var(--border);
      padding:.875rem;
      box-sizing:border-box;
      min-height: 11.25rem;
      min-width:0;
    }
    .label{
      font-size: .75rem;
      color: var(--muted);
      margin-bottom: .625rem;
      letter-spacing: .06em;
    }

    /* Analog clock */
    .analogWrap{
      display:flex;
      align-items:center;
      justify-content:center;
      height: calc(100% - 1.375rem);
      min-height: 8rem;
    }
    .clockSvg{
      width: min(17.5rem, 22vw);
      height: auto;
      filter: drop-shadow(0 .625rem 1.375rem var(--shadow));
    }
    html[data-orient="portrait"] .clockSvg{ width: min(20rem, 60vw); }
    .dial{fill: transparent; stroke: var(--border); stroke-width: 2;}
    .face{fill: rgba(0,0,0,.20);}
    html[data-theme="light"] .face{ fill: rgba(255,255,255,.55); }
    .tick{stroke: rgba(255,255,255,.35); stroke-width: 2;}
    .tickBig{stroke: rgba(255,255,255,.55); stroke-width: 3;}
    html[data-theme="light"] .tick{stroke: rgba(0,0,0,.30);}
    html[data-theme="light"] .tickBig{stroke: rgba(0,0,0,.45);}
    .handH{stroke: var(--fg); stroke-width: 5; stroke-linecap: round;}
    .handM{stroke: var(--fg); stroke-width: 4; stroke-linecap: round; opacity:.95;}
    .handS{stroke: var(--accent); stroke-width: 2; stroke-linecap: round; opacity:.95;}
    .pin{fill: var(--fg); opacity:.9;}

    /* Weather */
    .wxTop{
      display:grid;
      grid-template-columns: auto 1fr;
      gap:.75rem;
      align-items:center;
      padding-bottom:.625rem;
      border-bottom: 1px solid var(--border);
    }
    .wxIcon{
      font-size: 2.75rem;
      width: 3.5rem;
      text-align:center;
      filter: drop-shadow(0 .5rem 1rem var(--shadow));
    }
    .wxRight{min-width:0;}
    .wxTemp{
      font-size: 2.125rem;
      font-weight: 900;
      line-height:1;
      font-variant-numeric: tabular-nums;
    }
    .wxPlace{
      margin-top:.375rem;
      font-size: .875rem;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .wxDetail{
      margin-top:.375rem;
      font-size: .75rem;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .wxGrid{
      margin-top:.75rem;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:.625rem;
    }
    .wxPill{
      border: 1px solid var(--border);
      background: var(--panel2);
      border-radius: 1rem;
      padding:.625rem;
      box-sizing:border-box;
      min-width:0;
    }
    .wxPill .k{
      font-size:.6875rem;
      color: var(--muted);
      letter-spacing:.06em;
    }
    .wxPill .v{
      margin-top:.25rem;
      font-size: 1rem;
      font-weight:900;
      font-variant-numeric: tabular-nums;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .wxFoot{
      margin-top:.75rem;
      font-size:.75rem;
      color: var(--muted);
    }

    /* Stopwatch */
    .swRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:.75rem;
      flex-wrap:wrap;
    }
    .swDisplay{
      font-variant-numeric: tabular-nums;
      font-weight: 900;
      letter-spacing: .02em;
      font-size: 2.5rem;
      line-height:1.1;
      white-space:nowrap;
    }
    .swBtns{
      display:flex;
      gap:.625rem;
      flex-wrap:wrap;
    }

    /* RIGHT */
    #scene{position:absolute; inset:0; width:100%; height:100%;}
    .rightOverlay{
      position:absolute; inset:0;
      pointer-events:none;
      background: linear-gradient(to bottom, rgba(0,0,0,.06), rgba(0,0,0,.22));
      opacity: .45;
    }

    /* Â§©Ê∞óÊõ¥Êñ∞ÔºöÂè≥‰∏ä„Å∏ */
    .wxCorner{
      position:absolute;
      top: .875rem;
      right: .875rem;
      z-index:6;
      display:flex;
      gap:.625rem;
    }

    /* Êã°Â§ßÁ∏ÆÂ∞èÔºöËÉåÊôØ„Éë„Éç„É´Âè≥‰∏ã„Å∏ÔºàÂ∫ßÂ∏ÉÂõ£„Å™„Åó„ÉªÂ∞è„Åï„ÇÅÔºâ */
    .scaleCtl{
      position:absolute;
      right: .875rem;
      bottom: .875rem;
      z-index:6;
      display:flex;
      align-items:center;
      gap:6px;

      font-size: 12px;
      letter-spacing: .02em;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      text-shadow: 0 2px 8px rgba(0,0,0,.35);
      pointer-events:auto;
    }
    html[data-theme="light"] .scaleCtl{ text-shadow: 0 2px 8px rgba(0,0,0,.15); }

    .scaleCtl .sbtn{
      width: 28px;
      height: 28px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.18);
      color: var(--fg);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      cursor:pointer;
      pointer-events:auto;
    }
    html[data-theme="light"] .scaleCtl .sbtn{
      border: 1px solid rgba(0,0,0,.15);
      background: rgba(255,255,255,.55);
    }
    .scaleCtl .sbtn:active{transform: translateY(1px);}
    .scaleCtl .pct{
      min-width: 48px;
      text-align:center;
      font-variant-numeric: tabular-nums;
      font-weight: 900;
      opacity: .92;
      cursor:pointer;
      pointer-events:auto;
    }

    @media (max-width: 980px){
      .digital .time{font-size: 5.375rem;}
      .controls{flex-direction:row;}
      .swDisplay{font-size: 2.125rem;}
    }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- LEFT -->
    <section class="panel">
      <div class="leftInner">
        <div class="topRow">
          <div class="digital">
            <div class="time" id="time">--:--</div>
            <div class="date" id="date">----</div>
          </div>
          <div class="controls">
            <button class="btn" id="themeBtn">„Éõ„ÉØ„Ç§„Éà</button>
            <button class="btn" id="chatBtn">ChatGPT</button>
          </div>
        </div>

        <div class="midRow">
          <div class="card">
            <div class="label">ANALOG</div>
            <div class="analogWrap">
              <svg class="clockSvg" viewBox="0 0 200 200" aria-label="analog clock">
                <circle cx="100" cy="100" r="90" class="face"></circle>
                <circle cx="100" cy="100" r="92" class="dial"></circle>
                <g id="ticks"></g>
                <g transform="translate(100 100)">
                  <line id="handH" x1="0" y1="10" x2="0" y2="-42" class="handH"></line>
                  <line id="handM" x1="0" y1="14" x2="0" y2="-62" class="handM"></line>
                  <line id="handS" x1="0" y1="18" x2="0" y2="-70" class="handS"></line>
                  <circle r="6" class="pin"></circle>
                </g>
              </svg>
            </div>
          </div>

          <div class="card">
            <div class="label">WEATHER</div>

            <div class="wxTop">
              <div class="wxIcon" id="wxIcon">‚õÖÔ∏è</div>
              <div class="wxRight">
                <div class="wxTemp" id="wxTemp">--¬∞C</div>
                <div class="wxPlace" id="wxPlace">Â§©Ê∞óÂèñÂæóÂæÖ„Å°</div>
                <div class="wxDetail" id="wxDetail">‚Äî</div>
              </div>
            </div>

            <div class="wxGrid">
              <div class="wxPill">
                <div class="k">Êó•„ÅÆÂá∫ / Êó•„ÅÆÂÖ•</div>
                <div class="v" id="wxSun">‚Äî</div>
              </div>
              <div class="wxPill">
                <div class="k">È¢®</div>
                <div class="v" id="wxWind">‚Äî</div>
              </div>
              <div class="wxPill">
                <div class="k">‰ΩìÊÑü</div>
                <div class="v" id="wxFeels">‚Äî</div>
              </div>
              <div class="wxPill">
                <div class="k">ÊπøÂ∫¶</div>
                <div class="v" id="wxHum">‚Äî</div>
              </div>
            </div>

            <div class="wxFoot" id="wxUpdated">‚Äî</div>
          </div>
        </div>

        <div class="card">
          <div class="label">STOPWATCH</div>
          <div class="swRow">
            <div class="swDisplay" id="swText">00:00:00</div>
            <div class="swBtns">
              <button class="btn" id="swStartStop">START</button>
              <button class="btn" id="swReset">RESET</button>
            </div>
          </div>
        </div>

        <div style="flex:1"></div>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="panel" id="rightPanel">
      <canvas id="scene"></canvas>
      <div class="rightOverlay"></div>

      <!-- Â§©Ê∞óÊõ¥Êñ∞ÔºöÂè≥‰∏ä -->
      <div class="wxCorner">
        <button class="btn" id="wxBtn">Â§©Ê∞óÊõ¥Êñ∞</button>
      </div>

      <!-- Êã°Â§ßÁ∏ÆÂ∞èÔºöÂè≥‰∏ãÔºàÊóßÂ§©Ê∞óÊõ¥Êñ∞„ÅÆ‰ΩçÁΩÆÔºâ -->
      <div class="scaleCtl" aria-label="scale control">
        <div class="sbtn" id="scaleDown">‚àí</div>
        <div class="pct" id="scalePct">100%</div>
        <div class="sbtn" id="scaleUp">Ôºã</div>
      </div>
    </section>
  </div>

<script>
(function(){
  function storageGet(key){ try { return localStorage.getItem(key); } catch(e){ return null; } }
  function storageSet(key, val){ try { localStorage.setItem(key, val); } catch(e){} }
  function pad(n){ return (n<10?"0":"")+n; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function round2(x){ return Math.round(x*100)/100; }
  function lerp(a,b,t){ return a+(b-a)*t; }

  const root = document.documentElement;

  function setOrient(){
    const portrait = (window.matchMedia && window.matchMedia("(orientation: portrait)").matches) || (window.innerHeight > window.innerWidth);
    root.setAttribute("data-orient", portrait ? "portrait" : "landscape");
  }
  window.addEventListener("resize", setOrient);
  window.addEventListener("orientationchange", setOrient);
  setOrient();

  const themeKey = "standby_theme_v10";
  function applyTheme(t){
    root.setAttribute("data-theme", t);
    storageSet(themeKey, t);
    document.getElementById("themeBtn").textContent = (t === "light") ? "„ÉÄ„Éº„ÇØ" : "„Éõ„ÉØ„Ç§„Éà";
  }
  const savedTheme = storageGet(themeKey);
  if(savedTheme) applyTheme(savedTheme);
  else{
    let prefersLight = false;
    try{ prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches; }catch(e){}
    applyTheme(prefersLight ? "light" : "dark");
  }
  document.getElementById("themeBtn").addEventListener("click", ()=>{
    const cur = root.getAttribute("data-theme") || "dark";
    applyTheme(cur === "dark" ? "light" : "dark");
  });

  // canvas
  const canvas = document.getElementById("scene");
  const ctx = canvas.getContext("2d", {alpha:true});
  function resizeScene(){
    if(!canvas || !ctx) return;
    const r = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.max(1, Math.floor(rect.width  * r));
    canvas.height = Math.max(1, Math.floor(rect.height * r));
    ctx.setTransform(r,0,0,r,0,0);
  }
  function scheduleResizeScene(){ requestAnimationFrame(()=>resizeScene()); }
  window.addEventListener("resize", scheduleResizeScene);
  window.addEventListener("orientationchange", scheduleResizeScene);
  resizeScene();

  // UI scale
  const scaleKey = "standby_ui_scale_v3";
  const SCALE_MIN = 0.85, SCALE_MAX = 1.25, SCALE_STEP = 0.05;
  function getScale(){
    const raw = storageGet(scaleKey);
    let v = raw ? parseFloat(raw) : 1;
    if(!isFinite(v)) v = 1;
    return v;
  }
  function setScale(v){
    v = round2(clamp(v, SCALE_MIN, SCALE_MAX));
    root.style.setProperty("--ui-scale", v);
    storageSet(scaleKey, String(v));
    document.getElementById("scalePct").textContent = Math.round(v*100) + "%";
    scheduleResizeScene();
  }
  document.getElementById("scaleDown").addEventListener("click", ()=>setScale(getScale() - SCALE_STEP));
  document.getElementById("scaleUp").addEventListener("click", ()=>setScale(getScale() + SCALE_STEP));
  document.getElementById("scalePct").addEventListener("click", ()=>setScale(1));
  setScale(getScale());

  // chat
  document.getElementById("chatBtn").addEventListener("click", ()=>{
    window.open("https://chatgpt.com", "_blank");
  });

  // clock
  const timeEl = document.getElementById("time");
  const dateEl = document.getElementById("date");
  const handH = document.getElementById("handH");
  const handM = document.getElementById("handM");
  const handS = document.getElementById("handS");
  const dow = ["Êó•","Êúà","ÁÅ´","Ê∞¥","Êú®","Èáë","Âúü"];

  let sceneHour = 12, sceneMin = 0, sceneSec = 0;

  function rot(el, deg){ el.setAttribute("transform", "rotate("+deg+")"); }

  (function(){
    const ticksG = document.getElementById("ticks");
    let s = "";
    for(let i=0;i<60;i++){
      const a = (Math.PI*2)*(i/60);
      const r1 = 80;
      const r2 = (i%5===0)?70:74;
      const x1 = 100 + Math.sin(a)*r1;
      const y1 = 100 - Math.cos(a)*r1;
      const x2 = 100 + Math.sin(a)*r2;
      const y2 = 100 - Math.cos(a)*r2;
      const cls = (i%5===0) ? "tickBig" : "tick";
      s += '<line x1="'+x1.toFixed(2)+'" y1="'+y1.toFixed(2)+'" x2="'+x2.toFixed(2)+'" y2="'+y2.toFixed(2)+'" class="'+cls+'" />';
    }
    ticksG.innerHTML = s;
  })();

  function updateAnalog(d){
    const h = d.getHours()%12;
    const m = d.getMinutes();
    const s = d.getSeconds();
    const ms = d.getMilliseconds();
    const sec = s + ms/1000;
    const min = m + sec/60;
    const hour = h + min/60;
    rot(handS, sec*6);
    rot(handM, min*6);
    rot(handH, hour*30);
  }

  function tick(){
    const d = new Date();
    timeEl.textContent = pad(d.getHours())+":"+pad(d.getMinutes());
    dateEl.textContent = d.getFullYear()+"/"+pad(d.getMonth()+1)+"/"+pad(d.getDate())+" ("+dow[d.getDay()]+")";
    updateAnalog(d);
    sceneHour = d.getHours();
    sceneMin = d.getMinutes();
    sceneSec = d.getSeconds();
  }
  tick();
  setInterval(tick, 1000);

  // weather
  const wxIconEl = document.getElementById("wxIcon");
  const wxTempEl = document.getElementById("wxTemp");
  const wxPlaceEl = document.getElementById("wxPlace");
  const wxDetailEl = document.getElementById("wxDetail");
  const wxSunEl = document.getElementById("wxSun");
  const wxWindEl = document.getElementById("wxWind");
  const wxFeelsEl = document.getElementById("wxFeels");
  const wxHumEl = document.getElementById("wxHum");
  const wxUpdatedEl = document.getElementById("wxUpdated");

  let currentWxCode = null;
  let currentWxWind = 0;

  function weatherEmoji(code){
    if(code===0) return "‚òÄÔ∏è";
    if(code===1||code===2) return "üå§Ô∏è";
    if(code===3) return "‚òÅÔ∏è";
    if(code===45||code===48) return "üå´Ô∏è";
    if(code===51||code===53||code===55||code===56||code===57) return "üå¶Ô∏è";
    if(code===61||code===63||code===65||code===66||code===67) return "üåßÔ∏è";
    if(code===71||code===73||code===75||code===77) return "üå®Ô∏è";
    if(code===80||code===81||code===82) return "üåßÔ∏è";
    if(code===85||code===86) return "üå®Ô∏è";
    if(code===95||code===96||code===99) return "‚õàÔ∏è";
    return "‚õÖÔ∏è";
  }
  function codeText(code){
    const map = {
      0:"Âø´Êô¥",1:"Êô¥„Çå",2:"Êô¥„ÇåÊôÇ„ÄÖÊõá„Çä",3:"Êõá„Çä",45:"Èúß",48:"Èúß",
      51:"ÈúßÈõ®(Âº±)",53:"ÈúßÈõ®(‰∏≠)",55:"ÈúßÈõ®(Âº∑)",56:"ÂáçÁµêÈúßÈõ®(Âº±)",57:"ÂáçÁµêÈúßÈõ®(Âº∑)",
      61:"Èõ®(Âº±)",63:"Èõ®(‰∏≠)",65:"Èõ®(Âº∑)",66:"ÂáçÁµêÈõ®(Âº±)",67:"ÂáçÁµêÈõ®(Âº∑)",
      71:"Èõ™(Âº±)",73:"Èõ™(‰∏≠)",75:"Èõ™(Âº∑)",77:"Èú∞(„ÅÇ„Çâ„Çå)",
      80:"„Å´„Çè„ÅãÈõ®(Âº±)",81:"„Å´„Çè„ÅãÈõ®(‰∏≠)",82:"„Å´„Çè„ÅãÈõ®(Âº∑)",
      85:"„Å´„Çè„ÅãÈõ™(Âº±)",86:"„Å´„Çè„ÅãÈõ™(Âº∑)",
      95:"Èõ∑Èõ®",96:"Èõ∑Èõ®(Èõπ)",99:"Èõ∑Èõ®(Èõπ)"
    };
    return map[code] || ("Â§©Ê∞ó„Ç≥„Éº„Éâ " + code);
  }
  function setWx(state){
    wxTempEl.textContent = state.tempText || "--¬∞C";
    wxPlaceEl.textContent = state.place || "‚Äî";
    wxDetailEl.textContent = state.detail || "‚Äî";
    wxSunEl.textContent = state.sun || "‚Äî";
    wxWindEl.textContent = state.windText || "‚Äî";
    wxFeelsEl.textContent = state.feelsText || "‚Äî";
    wxHumEl.textContent = state.humText || "‚Äî";
    wxUpdatedEl.textContent = state.updated || "‚Äî";
    wxIconEl.textContent = state.icon || "‚õÖÔ∏è";
    if(typeof state.code==="number") currentWxCode = state.code;
    if(typeof state.wind==="number") currentWxWind = state.wind;
  }
  function fetchWithTimeout(url, ms){
    return new Promise((resolve, reject)=>{
      let done = false;
      const timer = setTimeout(()=>{ if(done) return; done=true; reject(new Error("timeout")); }, ms);
      fetch(url, {cache:"no-store"})
        .then(r=>{ if(!r.ok) throw new Error("http"); return r.json(); })
        .then(j=>{ if(done) return; done=true; clearTimeout(timer); resolve(j); })
        .catch(e=>{ if(done) return; done=true; clearTimeout(timer); reject(e); });
    });
  }
  function fmtHHMM(iso){
    if(!iso) return "‚Äî";
    const t = (iso.split("T")[1] || "");
    return t.slice(0,5) || "‚Äî";
  }
  function updateWeatherWithCoords(lat, lon, placeText){
    const url =
      "https://api.open-meteo.com/v1/forecast?latitude="+lat+
      "&longitude="+lon+
      "&current=temperature_2m,apparent_temperature,relative_humidity_2m,weather_code,wind_speed_10m"+
      "&daily=sunrise,sunset"+
      "&forecast_days=1"+
      "&timezone=Asia%2FTokyo";

    return fetchWithTimeout(url, 9000).then(wx=>{
      const cur = wx && wx.current ? wx.current : null;
      if(!cur) throw new Error("baddata");

      const temp = Math.round(cur.temperature_2m);
      const feels= (typeof cur.apparent_temperature === "number") ? Math.round(cur.apparent_temperature) : null;
      const hum  = (typeof cur.relative_humidity_2m === "number") ? Math.round(cur.relative_humidity_2m) : null;

      const code = cur.weather_code;
      const wind = Math.round(cur.wind_speed_10m);

      const sunrise = (wx.daily && wx.daily.sunrise && wx.daily.sunrise[0]) ? fmtHHMM(wx.daily.sunrise[0]) : "‚Äî";
      const sunset  = (wx.daily && wx.daily.sunset  && wx.daily.sunset[0])  ? fmtHHMM(wx.daily.sunset[0])  : "‚Äî";

      setWx({
        tempText: temp + "¬∞C",
        place: placeText,
        detail: codeText(code),
        sun: sunrise + " / " + sunset,
        windText: wind + "m/s",
        feelsText: (feels!==null ? (feels + "¬∞C") : "‚Äî"),
        humText: (hum!==null ? (hum + "%") : "‚Äî"),
        updated: "ÊúÄÁµÇÊõ¥Êñ∞: " + new Date().toLocaleTimeString("ja-JP",{hour:"2-digit",minute:"2-digit"}),
        icon: weatherEmoji(code),
        code,
        wind
      });
    });
  }
  function reverseGeocode(lat, lon){
    const url = "https://geocoding-api.open-meteo.com/v1/reverse?latitude="+lat+"&longitude="+lon+"&language=ja";
    return fetchWithTimeout(url, 9000).then(j=>{
      const p = j && j.results && j.results[0] ? j.results[0] : null;
      if(!p) return null;
      const parts = [];
      if(p.name) parts.push(p.name);
      if(p.admin1) parts.push(p.admin1);
      if(p.country) parts.push(p.country);
      return parts.join(", ");
    }).catch(()=>null);
  }
  function fallbackTokyo(reason){
    return updateWeatherWithCoords(35.681236, 139.767125, "Êù±‰∫¨Ôºà"+reason+"Ôºâ");
  }
  function updateWeather(){
    setWx({
      place:"Â§©Ê∞óÂèñÂæó‰∏≠‚Ä¶",
      tempText:"--¬∞C",
      detail:"‚Äî",
      sun:"‚Äî",
      windText:"‚Äî",
      feelsText:"‚Äî",
      humText:"‚Äî",
      updated:"‚Äî",
      icon:"‚õÖÔ∏è"
    });

    const hardTimeout = setTimeout(()=>{ fallbackTokyo("ÂèñÂæó„ÅåÈï∑Âºï„ÅÑ„Åü„Åü„ÇÅÊù±‰∫¨„ÇíË°®Á§∫"); }, 12000);
    const finish = ()=>clearTimeout(hardTimeout);

    if(!navigator.geolocation){
      fallbackTokyo("‰ΩçÁΩÆÊÉÖÂ†±ÈùûÂØæÂøú").then(finish).catch(finish);
      return;
    }
    navigator.geolocation.getCurrentPosition((pos)=>{
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;

      reverseGeocode(lat, lon).then(place=>{
        const label = place || ("Á∑ØÂ∫¶ " + lat.toFixed(2) + " / ÁµåÂ∫¶ " + lon.toFixed(2));
        return updateWeatherWithCoords(lat, lon, label);
      }).then(finish).catch(()=>{
        fallbackTokyo("Â§©Ê∞óAPIÂ§±Êïó").then(finish).catch(finish);
      });
    }, (err)=>{
      const reason = (err && err.code === 1) ? "‰ΩçÁΩÆÊÉÖÂ†±ÊãíÂê¶" : "‰ΩçÁΩÆÊÉÖÂ†±„Ç®„É©„Éº";
      fallbackTokyo(reason).then(finish).catch(finish);
    }, { enableHighAccuracy:false, timeout:8000, maximumAge: 10*60*1000 });
  }

  document.getElementById("wxBtn").addEventListener("click", updateWeather);
  updateWeather();
  setInterval(updateWeather, 10*60*1000);

  // stopwatch
  const swText = document.getElementById("swText");
  const swStartStop = document.getElementById("swStartStop");
  const swReset = document.getElementById("swReset");

  let swRunning = false;
  let swBaseMs = 0;
  let swStartAt = 0;
  let swTimer = 0;

  function fmtHMS(ms){
    ms = Math.max(0, ms|0);
    const totalSec = Math.floor(ms/1000);
    const s = totalSec % 60;
    const totalMin = Math.floor(totalSec/60);
    const m = totalMin % 60;
    const h = Math.floor(totalMin/60);
    return pad(h)+":"+pad(m)+":"+pad(s);
  }
  function swNowMs(){ return swRunning ? (swBaseMs + (performance.now() - swStartAt)) : swBaseMs; }
  function swRender(){ swText.textContent = fmtHMS(swNowMs()); }
  function swSetButtons(){ swStartStop.textContent = swRunning ? "STOP" : "START"; }
  function swStartLoop(){ clearInterval(swTimer); swTimer = setInterval(swRender, 200); }
  function swStopLoop(){ clearInterval(swTimer); swTimer = 0; }

  swStartStop.addEventListener("click", ()=>{
    if(!swRunning){
      swRunning = true;
      swStartAt = performance.now();
      swSetButtons();
      swStartLoop();
    }else{
      swBaseMs = swNowMs();
      swRunning = false;
      swSetButtons();
      swStopLoop();
      swRender();
    }
  });
  swReset.addEventListener("click", ()=>{
    swRunning = false;
    swBaseMs = 0;
    swSetButtons();
    swStopLoop();
    swRender();
  });
  swSetButtons();
  swRender();

  // background animation
  function skyParams(hourFloat){
    const nightTop=[18,16,40], nightBot=[10,10,22];
    const dawnTop =[255,170,135], dawnBot =[120,70,130];
    const dayTop  =[70,175,255], dayBot  =[210,245,255];
    const duskTop =[255,135,155], duskBot=[75,45,120];

    const mix=(c1,c2,k)=>[lerp(c1[0],c2[0],k), lerp(c1[1],c2[1],k), lerp(c1[2],c2[2],k)];

    const h = hourFloat;
    let top, bot, nightness;

    if(h < 5){
      top = nightTop; bot = nightBot; nightness = 1;
    }else if(h < 8){
      const k = (h-5)/3;
      top = mix(nightTop, dawnTop, k);
      bot = mix(nightBot, dawnBot, k);
      nightness = 1-k*0.9;
    }else if(h < 16){
      const k2 = (h-8)/8;
      top = mix(dawnTop, dayTop, k2);
      bot = mix(dawnBot, dayBot, k2);
      nightness = 0;
    }else if(h < 19){
      const k3 = (h-16)/3;
      top = mix(dayTop, duskTop, k3);
      bot = mix(dayBot, duskBot, k3);
      nightness = k3*0.55;
    }else{
      const k4 = (h-19)/5;
      top = mix(duskTop, nightTop, clamp(k4,0,1));
      bot = mix(duskBot, nightBot, clamp(k4,0,1));
      nightness = 0.55 + 0.45*clamp(k4,0,1);
    }
    return {top, bot, nightness};
  }
  function arcPos(p){
    const x = lerp(0.06, 0.94, p);
    const y = 0.62 - Math.sin(p*Math.PI)*0.44;
    return {x, y};
  }

  const stars=[];
  for(let i=0;i<190;i++){
    stars.push({x:((i*97)%1000)/1000, y:((i*173)%1000)/1000, s:((i*37)%9)+1});
  }
  const dust=[];
  for(let k=0;k<80;k++){
    dust.push({x:Math.random(), y:Math.random(), r:1+Math.random()*2.6, v:0.004+Math.random()*0.01, p:Math.random()*6.28});
  }
  function pick(arr){ return arr[(Math.random()*arr.length)|0]; }
  function makeFish(){
    const cols = [
      {a:[255,120,190], b:[255,190,230]},
      {a:[120,210,255], b:[200,245,255]},
      {a:[255,205,130], b:[255,240,200]},
      {a:[170,140,255], b:[220,200,255]},
      {a:[120,255,210], b:[200,255,240]}
    ];
    const c = pick(cols);
    return {
      x: Math.random()*1.2 - 0.1,
      y: Math.random()*0.55 + 0.18,
      v: 0.020 + Math.random()*0.050,
      s: 0.9 + Math.random()*1.2,
      dir: (Math.random()<0.5)?1:-1,
      phase: Math.random()*6.28,
      c1: c.a, c2: c.b
    };
  }
  const fishes=[];
  for(let f=0; f<9; f++) fishes.push(makeFish());

  let bubbles=[];
  function spawnBubble(x,y){
    bubbles.push({x, y, r:1.5+Math.random()*3, a:0.22+Math.random()*0.25, vy:0.02+Math.random()*0.05});
    if(bubbles.length>140) bubbles.shift();
  }
  function rgb(c, a){ return "rgba("+(c[0]|0)+","+(c[1]|0)+","+(c[2]|0)+","+a+")"; }

  function drawFish(px, py, size, dir, c1, c2, t){
    ctx.save();
    ctx.translate(px, py);
    ctx.scale(dir, 1);

    const w = 42*size;
    const h = 16*size;
    const wag = Math.sin(t*3.0 + (py*0.01) + (px*0.003)) * (7*size);

    const grad = ctx.createLinearGradient(-w*0.25,0,w*0.35,0);
    grad.addColorStop(0, rgb(c2, 0.90));
    grad.addColorStop(1, rgb(c1, 0.90));

    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.beginPath();
    ctx.ellipse(0, h*0.55, w*0.40, h*0.28, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(0, 0, w*0.45, h*0.52, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,.18)";
    ctx.beginPath();
    ctx.ellipse(w*0.18, -h*0.10, w*0.18, h*0.18, 0.2, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = rgb(c2, 0.55);
    ctx.beginPath();
    ctx.moveTo(-w*0.05, -h*0.45);
    ctx.lineTo(w*0.10, -h*0.65);
    ctx.lineTo(w*0.18, -h*0.35);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = rgb(c2, 0.40);
    ctx.beginPath();
    ctx.moveTo(w*0.02, h*0.08);
    ctx.lineTo(w*0.18, h*0.30);
    ctx.lineTo(w*0.06, h*0.36);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = rgb(c1, 0.80);
    ctx.beginPath();
    ctx.moveTo(-w*0.42, 0);
    ctx.lineTo(-w*0.62, -h*0.35 + wag);
    ctx.lineTo(-w*0.55, 0 + wag*0.2);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(-w*0.42, 0);
    ctx.lineTo(-w*0.62, h*0.35 + wag);
    ctx.lineTo(-w*0.55, 0 + wag*0.2);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.beginPath();
    ctx.arc(w*0.22, -h*0.05, 2.4*size, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,.7)";
    ctx.beginPath();
    ctx.arc(w*0.24, -h*0.08, 1.0*size, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function wxKind(code){
    if(code == null) return "unknown";
    if(code===0||code===1) return "clear";
    if(code===2||code===3) return "cloudy";
    if(code===45||code===48) return "fog";
    if(code===51||code===53||code===55||code===56||code===57) return "drizzle";
    if(code===61||code===63||code===65||code===66||code===67||code===80||code===81||code===82||code===95||code===96||code===99) return "rain";
    if(code===71||code===73||code===75||code===77||code===85||code===86) return "snow";
    return "cloudy";
  }
  const drops=[];
  for(let d=0; d<150; d++) drops.push({x:Math.random(), y:Math.random(), v:0.9+Math.random()*1.4, l:0.015+Math.random()*0.02});
  const flakes=[];
  for(let s=0; s<120; s++) flakes.push({x:Math.random(), y:Math.random(), v:0.12+Math.random()*0.25, w:(Math.random()*2-1)*0.10});

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    const t = now/1000;

    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    const hourFloat = sceneHour + sceneMin/60 + sceneSec/3600;
    const sp = skyParams(hourFloat);

    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "rgb("+(sp.top[0]|0)+","+(sp.top[1]|0)+","+(sp.top[2]|0)+")");
    g.addColorStop(1, "rgb("+(sp.bot[0]|0)+","+(sp.bot[1]|0)+","+(sp.bot[2]|0)+")");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    const pulse = 0.08 + 0.06*(0.5+0.5*Math.sin(t*0.35));
    ctx.globalAlpha = pulse;
    const g2 = ctx.createLinearGradient(0, H*0.15 + Math.sin(t*0.2)*18, W, H*0.85);
    g2.addColorStop(0, "rgba(255,140,190,0.35)");
    g2.addColorStop(0.5, "rgba(140,160,255,0.18)");
    g2.addColorStop(1, "rgba(255,210,140,0.22)");
    ctx.fillStyle = g2;
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    if(sp.nightness > 0.12){
      const base = clamp((sp.nightness-0.1)/0.9, 0, 1);
      for(let i=0;i<stars.length;i++){
        const st = stars[i];
        const tw = 0.35 + 0.65*(0.5+0.5*Math.sin(t*1.1 + st.s));
        ctx.globalAlpha = base * 0.70 * tw;
        ctx.fillStyle = "white";
        ctx.fillRect(st.x*W, st.y*H*0.70, 2, 2);
      }
      ctx.globalAlpha = 1;
    }

    const sunActive = (hourFloat >= 6 && hourFloat < 18);
    const progSun = clamp((hourFloat - 6)/12, 0, 1);
    const progMoon = clamp(((hourFloat >= 18 ? hourFloat : hourFloat+24) - 18)/12, 0, 1);

    if(sunActive){
      const pS = arcPos(progSun);
      const sx = pS.x*W, sy = pS.y*H;
      ctx.fillStyle = "rgba(255,214,140,.98)";
      ctx.beginPath(); ctx.arc(sx, sy, 38, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 0.55;
      const rg = ctx.createRadialGradient(sx,sy,0,sx,sy,130);
      rg.addColorStop(0, "rgba(255,214,140,.35)");
      rg.addColorStop(0.4, "rgba(255,180,160,.18)");
      rg.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = rg;
      ctx.beginPath(); ctx.arc(sx, sy, 130, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }else{
      const pM = arcPos(progMoon);
      const mx = pM.x*W, my = pM.y*H;
      ctx.fillStyle = "rgba(235,245,255,.95)";
      ctx.beginPath(); ctx.arc(mx, my, 32, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 0.38;
      const rg2 = ctx.createRadialGradient(mx,my,0,mx,my,110);
      rg2.addColorStop(0, "rgba(235,245,255,.22)");
      rg2.addColorStop(0.55, "rgba(190,210,255,.10)");
      rg2.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = rg2;
      ctx.beginPath(); ctx.arc(mx, my, 110, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.globalAlpha = 0.10;
    for(let m=0; m<6; m++){
      const yy = H*(0.20 + m*0.12) + Math.sin(t*0.25 + m)*18;
      const hh = 70 + m*8;
      const gg = ctx.createLinearGradient(0,yy,0,yy+hh);
      gg.addColorStop(0, "rgba(255,255,255,0)");
      gg.addColorStop(0.5, "rgba(255,255,255,0.25)");
      gg.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = gg;
      ctx.fillRect(0, yy, W, hh);
    }
    ctx.globalAlpha = 1;

    for(let dp=0; dp<dust.length; dp++){
      const du = dust[dp];
      du.p += dt*(0.6 + du.v*10);
      du.x += du.v*dt*(0.6 + 0.7*Math.sin(du.p));
      if(du.x > 1.1) du.x = -0.1;
      const dx = du.x*W;
      const dy = (du.y + 0.02*Math.sin(t*0.25 + du.p))*H;
      ctx.globalAlpha = 0.10 + 0.12*(0.5+0.5*Math.sin(du.p));
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.beginPath(); ctx.arc(dx, dy, du.r, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    for(let j=0; j<fishes.length; j++){
      const fi = fishes[j];
      fi.x += fi.v * dt * fi.dir;
      fi.phase += dt*(0.9 + fi.s*0.2);

      if(fi.dir===1 && fi.x > 1.28){ fi.x = -0.28; fi.y = Math.random()*0.55 + 0.18; }
      if(fi.dir===-1 && fi.x < -0.28){ fi.x = 1.28; fi.y = Math.random()*0.55 + 0.18; }

      const px = fi.x * W;
      const py = fi.y * H + Math.sin(fi.phase + j)*12;
      const size = 0.55 * fi.s;

      if(Math.random() < 0.18){
        const bx = px - fi.dir*(32*size);
        const by = py + (Math.random()*10-5);
        spawnBubble(bx, by);
      }

      ctx.globalAlpha = 0.90 - fi.y*0.18;
      drawFish(px, py, size, fi.dir, fi.c1, fi.c2, t);
      ctx.globalAlpha = 1;
    }

    for(let b=0; b<bubbles.length; b++){
      const bu = bubbles[b];
      bu.y -= bu.vy * (H*dt);
      bu.x += Math.sin(t*0.6 + b)*0.25;
      bu.a *= 0.996;
      ctx.globalAlpha = bu.a;
      ctx.strokeStyle = "rgba(255,255,255,.35)";
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.arc(bu.x, bu.y, bu.r, 0, Math.PI*2); ctx.stroke();
    }
    ctx.globalAlpha = 1;
    bubbles = bubbles.filter(bu => bu.a > 0.03 && bu.y > -30);

    const kind = wxKind(currentWxCode);
    if(kind==="rain" || kind==="drizzle"){
      ctx.globalAlpha = 0.22;
      ctx.strokeStyle = (root.getAttribute("data-theme")==="light") ? "rgba(0,0,0,.22)" : "rgba(255,255,255,.16)";
      ctx.lineWidth = 2;
      for(let rr=0; rr<drops.length; rr++){
        const dr = drops[rr];
        dr.y += dr.v * dt * 0.9;
        dr.x += 0.06 * dt * (1 + (currentWxWind? currentWxWind/18 : 0));
        if(dr.y > 1){ dr.y = -Math.random()*0.2; dr.x = Math.random(); }
        if(dr.x > 1.1) dr.x = -0.1;
        const x = dr.x*W, y = dr.y*H;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+12, y+H*dr.l);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }
    if(kind==="snow"){
      ctx.globalAlpha = 0.50;
      ctx.fillStyle = (root.getAttribute("data-theme")==="light") ? "rgba(255,255,255,.95)" : "rgba(255,255,255,.80)";
      for(let ss=0; ss<flakes.length; ss++){
        const fl = flakes[ss];
        fl.y += fl.v * dt;
        fl.x += (fl.w * dt) + 0.02*Math.sin(t*0.6 + fl.y*10)*dt;
        if(fl.y > 1){ fl.y = -Math.random()*0.2; fl.x = Math.random(); }
        if(fl.x > 1.1) fl.x = -0.1;
        ctx.fillRect(fl.x*W, fl.y*H, 2, 2);
      }
      ctx.globalAlpha = 1;
    }

    ctx.globalAlpha = 0.14;
    const vg = ctx.createRadialGradient(W*0.55, H*0.45, 50, W*0.55, H*0.45, Math.max(W,H)*0.85);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, "rgba(0,0,0,.55)");
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
